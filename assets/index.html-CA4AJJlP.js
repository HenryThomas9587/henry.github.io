import{_ as n,c as s,b as a,a as i,d as l,r as e,o}from"./app-BNwF3TyR.js";const d={};function h(p,t){const r=e("Mermaid");return o(),s("div",null,[t[0]||(t[0]=a("h2",{id:"章节概览",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#章节概览"},[a("span",null,"章节概览")])],-1)),i(r,{id:"mermaid-3",code:"eJyFVd1O20gUvu9TWKoq7UpGxXZogYuVXBOk1SaSBdFedNSLtJgfbSDZELTtnVM2NKGBhBIaCuEnFAqrFQGWFoITyMNsZmxf9RX2ODM2DquqSBP5O+ebb87fDBPJaGKSC43c4+BvJB5P/YDadd1685noh+36Ms6cWScLz3681/E/eMB5TnJUxdtvO2YlfLuHmp917CFkGq2ODnNyPRyp6LhpML+AyPtT+5+Kw2ltWSdpZhcRzhzhM92uGtgoMKOEsFEyS0dfmxt2Kf2vnrb1XLt+Ax+4dAJHgIhpfCJbO5SvILy5S7Yr/sOtm3ncPGtfL9h/r5O1LCMKKBSdTsSTKY6UL+zyZ5I9Zx4RkctLXMzaesO6WXG871x1iKa4Yr8puEa3PrRgZq1MztcoU4Zkbm1su4rIbh235vHZNoTmGgUkTyQ1bVqbSUG0XuSuW0Q/z6S0ieRU6hW4cS1P1vxuCf0ajU2NUS+p5CBDnzeAIlpyemommpqKzwDBbGTJ8V6H0GGEZWhig3xJ++MMywIaiY470ZD1VbO4YB1+/NrMQwftvQV80rT0jEsUkRp9GZ/tKBdwpu6QawbeMcyq7nIk9DT6HBhP4/FfNC2hJSHHVWgpC0ENI1vfAOwMUZP1XQ0LyDuMthwUtET8xeTDFGTksqBXhSKpZu31C1L7ApTf5+LJuWmOLK6ZB3ACZUkOq23seyy8v0HWTsnyAS6UXVIAkfIBbpXx/hLOXtBiwhyS3KFVzd+22jzOtRuXdrlm7613bEEV+W1ULghddabZKOCrFnl37FrFrsthbvwJkzLqOmG6lnfwcZEGCxGIqvJQUhXXH7hbEl9UixdET5OKQaPvmEfDI+iOnSqBQ0DmZh0X8/Su0Ryphawuta8rHhECrtZwbcO5Z66W5/RdTqecSzVsrDpXNLNkXtecj/UdnIUCu1GSrXmrWoUHxv5QdKOMhNAdM5WPOO+EfmjNX7cbH6G6TteWCtYp3GXdLrHhijiPRu3KLn0AHl7cBJJd0a1Padpga/G1+frKpUpIkVUWg6OWXcB5w7nJeo68/YtTOJJ9z8kuO4Bw5RTG2aHV50l+hWSht24mVmvbmZ7MuXne8B5RrqfnJ3gW72C5GwfVbgxl7DZEQvQUJdyBIT9Q6KNIHYIfiH4g0T10C6UxQGkMSOwgmUIaGENhGjZDKk1KURmTabqQqbqQHe/CAHsHmC7d60G614N0r0rThVegG1KyB++QAzSfID0YrmA3pJs9SDd7kG2Gdrhtodt9BirgM7ACRmjZYWK7IeV7kB7oQXagcy12L+Hhg0vWvsp1bC9i0dnZIW2cex6b00ZTr2IaNz4Viw3eH+hV5OEBfjaVjP+mDd4X+h71Kb0M9vwxNZaaHBQTL7s14snozESXyvBwsLdf9FSGh/uHe7+n4vyHmvGLyH1Dj+THnogYfDwkuZrfEklqY91xyE8GBE9iqD8gCX3fkUjMJROxrmyU4IA01O+pPJKFJwPy/1VuZehV80rrcyhhPsQrfEjgQyIfknhF4BWRVyR/Df10mVdUPizzahg+gKsCWYVtagCsAiwRlgRuAZYIy/kO+GrpEwuqPEwsLBGWBCvgz9VHhLnjnel0fkTnR/Lq6mNFQjzMIywRlgQr4Mv4P+ZIzUI="}),t[1]||(t[1]=l('<p>本章探讨分布式系统中的强一致性保证和共识算法，这是构建容错分布式系统的理论基础。主要内容包括：</p><ul><li><strong>线性一致性（Linearizability）</strong>：最强的一致性模型，使分布式系统表现得像单机系统</li><li><strong>因果一致性（Causal Consistency）</strong>：通过逻辑时钟实现的弱化一致性模型</li><li><strong>全序广播（Total Order Broadcast）</strong>：保证消息有序传递的通信原语</li><li><strong>共识算法（Consensus Algorithms）</strong>：Paxos、Raft、Zab 等经典算法</li><li><strong>分布式事务</strong>：基于共识的原子提交协议</li></ul><h2 id="一致性模型" tabindex="-1"><a class="header-anchor" href="#一致性模型"><span>一致性模型</span></a></h2><h3 id="线性一致性-linearizability" tabindex="-1"><a class="header-anchor" href="#线性一致性-linearizability"><span>线性一致性（Linearizability）</span></a></h3><p><strong>定义</strong>：线性一致性使复制系统表现得像只有一份数据副本，所有操作都原子性地作用于这份数据。</p><p><strong>核心特性</strong>：</p><ol><li><strong>唯一性（Uniqueness）</strong>：每个操作看起来在其开始和结束之间的某个时间点生效</li><li><strong>顺序性（Ordering）</strong>：如果操作 A 在操作 B 开始前完成，则 B 必须看到 A 的效果</li><li><strong>原子性（Atomicity）</strong>：从外部观察者角度，操作是瞬时完成的</li></ol><p><strong>新鲜性保证</strong>：一旦写操作完成，所有后续读操作必须返回该值或更新的值。</p><p><strong>典型应用场景</strong>：</p><ul><li><strong>领导者选举和锁服务</strong>：防止脑裂（split-brain）场景</li><li><strong>唯一性约束</strong>：确保用户名、文件路径等全局唯一</li><li><strong>跨通道时序依赖</strong>：协调不同通信渠道之间的操作</li></ul><p><strong>实现挑战</strong>：</p><table><thead><tr><th>复制方式</th><th>线性一致性</th><th>说明</th></tr></thead><tbody><tr><td>单主复制</td><td>可能支持</td><td>需要仔细处理故障切换，避免脑裂</td></tr><tr><td>多主复制</td><td>不支持</td><td>并发写入导致冲突，无法保证全局顺序</td></tr><tr><td>无主复制（Quorum）</td><td>不一定支持</td><td>网络延迟可能导致读到旧值</td></tr></tbody></table><h3 id="因果一致性-causal-consistency" tabindex="-1"><a class="header-anchor" href="#因果一致性-causal-consistency"><span>因果一致性（Causal Consistency）</span></a></h3><p>因果一致性是比线性一致性更弱但更高效的一致性模型，只保证有因果关系的操作按顺序执行。</p><p><strong>优势</strong>：</p><ul><li>不需要全局协调</li><li>性能开销更小</li><li>可以在分区时继续工作</li></ul><h2 id="逻辑时钟与-id-生成" tabindex="-1"><a class="header-anchor" href="#逻辑时钟与-id-生成"><span>逻辑时钟与 ID 生成</span></a></h2><h3 id="lamport-时间戳" tabindex="-1"><a class="header-anchor" href="#lamport-时间戳"><span>Lamport 时间戳</span></a></h3><p><strong>原理</strong>：在不依赖物理时钟同步的情况下提供因果顺序。</p><p><strong>实现机制</strong>：</p><ul><li>每个节点维护一个计数器和唯一 ID</li><li>时间戳格式：<code>(counter, node_id)</code></li><li>计数器在事件发生时递增</li><li>接收消息时，将计数器更新为 <code>max(local_counter, received_counter) + 1</code></li></ul><p><strong>特点</strong>：</p><ul><li>提供全序关系（total ordering）</li><li>无法区分并发事件</li><li>不能反向推导因果关系</li></ul><h3 id="混合逻辑时钟-hybrid-logical-clocks" tabindex="-1"><a class="header-anchor" href="#混合逻辑时钟-hybrid-logical-clocks"><span>混合逻辑时钟（Hybrid Logical Clocks）</span></a></h3><p>结合物理时间和逻辑排序的优点：</p><ul><li>像物理时钟一样跟踪经过的时间</li><li>像 Lamport 时钟一样维护因果一致性</li><li>最小化与物理时间的偏差</li></ul><h3 id="线性一致的-id-生成器" tabindex="-1"><a class="header-anchor" href="#线性一致的-id-生成器"><span>线性一致的 ID 生成器</span></a></h3><p><strong>实现方式</strong>：</p><ol><li><strong>单节点生成器</strong>：使用原子递增操作</li><li><strong>批量分配</strong>：预分配 ID 范围以提高性能</li><li><strong>基于共识的分布式生成</strong>：使用共识算法协调 ID 分配</li></ol><h2 id="共识算法" tabindex="-1"><a class="header-anchor" href="#共识算法"><span>共识算法</span></a></h2><h3 id="共识问题定义" tabindex="-1"><a class="header-anchor" href="#共识问题定义"><span>共识问题定义</span></a></h3><p>共识解决了让分布式节点就单个值达成一致的基本问题，同时容忍节点故障。</p><p><strong>必须满足的属性</strong>：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Agreement（一致性）</td><td>没有两个节点做出不同的决定</td></tr><tr><td>Integrity（完整性）</td><td>节点不能改变已做出的决定</td></tr><tr><td>Validity（有效性）</td><td>决定的值必须是某个节点提议的</td></tr><tr><td>Termination（终止性）</td><td>未崩溃的节点最终会做出决定</td></tr></tbody></table><h3 id="等价问题" tabindex="-1"><a class="header-anchor" href="#等价问题"><span>等价问题</span></a></h3><p>以下问题都可以归约为共识问题：</p><ul><li>线性一致的 compare-and-set 操作</li><li>分布式事务中的原子提交</li><li>全序广播（共享日志）</li><li>领导者选举和分布式锁</li></ul><h3 id="主流共识算法" tabindex="-1"><a class="header-anchor" href="#主流共识算法"><span>主流共识算法</span></a></h3><h4 id="raft" tabindex="-1"><a class="header-anchor" href="#raft"><span>Raft</span></a></h4><p><strong>特点</strong>：</p><ul><li>设计目标是易于理解</li><li>使用任期号（term number）进行领导者选举</li><li>强领导者模型（strong leader）</li></ul><p><strong>工作流程</strong>：</p><ol><li><strong>领导者选举</strong>：节点超时后发起选举，获得多数票成为领导者</li><li><strong>日志复制</strong>：领导者接收客户端请求，复制到多数节点</li><li><strong>安全性保证</strong>：只有包含所有已提交日志的节点才能成为领导者</li></ol><h4 id="paxos-multi-paxos" tabindex="-1"><a class="header-anchor" href="#paxos-multi-paxos"><span>Paxos / Multi-Paxos</span></a></h4><p><strong>特点</strong>：</p><ul><li>经典共识算法，理论基础</li><li>使用提案号（proposal number）</li><li>Multi-Paxos 优化了连续决策的性能</li></ul><p><strong>阶段</strong>：</p><ol><li><strong>准备阶段（Prepare）</strong>：提议者发送提案号，获取承诺</li><li><strong>接受阶段（Accept）</strong>：提议者发送值，获取多数接受</li></ol><h4 id="zab-zookeeper-atomic-broadcast" tabindex="-1"><a class="header-anchor" href="#zab-zookeeper-atomic-broadcast"><span>Zab（ZooKeeper Atomic Broadcast）</span></a></h4><p><strong>特点</strong>：</p><ul><li>用于 ZooKeeper 协调服务</li><li>保证全序广播</li><li>支持崩溃恢复</li></ul><p><strong>核心机制</strong>：</p><ul><li>使用 epoch 号标识领导者任期</li><li>两阶段提交协议</li><li>同步阶段确保新领导者拥有最新状态</li></ul><h3 id="共识算法通用模式" tabindex="-1"><a class="header-anchor" href="#共识算法通用模式"><span>共识算法通用模式</span></a></h3>',54)),i(r,{id:"mermaid-481",code:"eJyFkk9PGkEUwO9+iole2gQtOysIHJrQZTlxIPW48YC6gikCXSBtb2ArFcu/RikNYigGWtKk0MYIyh/5Mszs7rfouCMw1NbuZWfnvfeb33s7fsUXCQDP8wVAnvWYT4k9ktDBL62dUlslfFHEl0m1+WHj8YKREI1v0gJvwBeVOWkRcCtAP0+h9kBLHOiJ9PjqBixuGLm3j8hJ4+FIPWkCORLeCjyJycoeQPku/vKenDDu93GlymRDSTvaV/ev8VFRbTQpbkpn8nhJryS0r0lUL+PiT5KK01nt7RANj0kNezpYXn5KsPTFGwE5tP23XiDpBa4AnC/g2qH+uYNbl2wjXk6aiqDCR/AyHlbie0Atv9O6Vb2cJ9ukVGu1UGLAVJGGJmH9e0ZrJ9F1Bx1nUe+ERRt6XviQHk/0eENv3Kvf1xM4Sct10U1pIoZzDZQvoUKOVsxZCVDSE2W12sDpBK6k6ciJEvlNKHWh/vjEcg034UG3VeK2StxKDTQqoXoWHXZYNw8nUey43yDHoV6eZuKzmnraQsNzNMjTKqYGSuPRGZkXq4gzafX0ChUyeq13S0l/02oZ9hzD1fOHq3Gn6YSNO2ts0uVsl9bQ5WyXXhi6nO2uUu5W0BeNuuQdsBmMy+uxN0EZ7OwGg44lu1lwuu2maEwJv5AdS5zFahHMd5/Lr3a3YwEHjLyeZ4QVX8g/R3G7RbMNTilut81t/h/Fr8hyiIU4LS6rc20KgeKai58w/wWJxJVIcE5FEO28yzalWJ3cM7vzPmWGuZv5dDBMRORMIjSJPNsxE/ZyJi9k+mBCAmcSIGvHxDycyQOZ834DhBDe2Q=="}),t[2]||(t[2]=l('<h2 id="状态机复制-state-machine-replication" tabindex="-1"><a class="header-anchor" href="#状态机复制-state-machine-replication"><span>状态机复制（State Machine Replication）</span></a></h2><p><strong>原理</strong>：共识算法使得状态机复制成为可能。</p><p><strong>工作机制</strong>：</p><ul><li>所有副本以相同顺序处理相同操作</li><li>确定性状态机保持一致</li><li>支持可序列化事务和事件溯源</li></ul><p><strong>应用</strong>：</p><ul><li>分布式数据库</li><li>分布式配置管理</li><li>分布式队列和消息系统</li></ul><h2 id="全序广播-total-order-broadcast" tabindex="-1"><a class="header-anchor" href="#全序广播-total-order-broadcast"><span>全序广播（Total Order Broadcast）</span></a></h2><p><strong>定义</strong>：保证所有节点以相同顺序接收消息的通信原语。</p><p><strong>与共识的关系</strong>：</p><ul><li>全序广播等价于重复的共识</li><li>每条消息相当于一轮共识</li><li>共识可以通过全序广播实现</li></ul><p><strong>实现方式</strong>：</p><ul><li>使用共识算法对消息排序</li><li>领导者负责分配序列号</li><li>日志复制确保顺序一致</li></ul><h2 id="分布式事务与原子提交" tabindex="-1"><a class="header-anchor" href="#分布式事务与原子提交"><span>分布式事务与原子提交</span></a></h2><h3 id="两阶段提交-2pc" tabindex="-1"><a class="header-anchor" href="#两阶段提交-2pc"><span>两阶段提交（2PC）</span></a></h3><p><strong>角色</strong>：</p><ul><li><strong>协调者（Coordinator）</strong>：管理事务提交流程</li><li><strong>参与者（Participants）</strong>：执行事务操作的节点</li></ul><p><strong>阶段</strong>：</p><ol><li><p><strong>准备阶段（Prepare Phase）</strong></p><ul><li>协调者向所有参与者发送准备请求</li><li>参与者执行事务，写入日志，返回投票（Yes/No）</li></ul></li><li><p><strong>提交阶段（Commit Phase）</strong></p><ul><li>如果所有参与者投 Yes，协调者发送提交命令</li><li>如果任何参与者投 No，协调者发送中止命令</li><li>参与者执行命令并返回确认</li></ul></li></ol><p><strong>问题</strong>：</p><ul><li>协调者单点故障会导致参与者阻塞</li><li>需要持久化日志以支持崩溃恢复</li><li>性能开销较大</li></ul><h3 id="三阶段提交-3pc" tabindex="-1"><a class="header-anchor" href="#三阶段提交-3pc"><span>三阶段提交（3PC）</span></a></h3><p>在 2PC 基础上增加超时机制，减少阻塞，但仍无法完全解决网络分区问题。</p><h2 id="权衡与限制" tabindex="-1"><a class="header-anchor" href="#权衡与限制"><span>权衡与限制</span></a></h2><h3 id="共识的代价" tabindex="-1"><a class="header-anchor" href="#共识的代价"><span>共识的代价</span></a></h3><table><thead><tr><th>方面</th><th>限制</th></tr></thead><tbody><tr><td>容错能力</td><td>需要严格多数才能运行（3 节点容忍 1 个故障）</td></tr><tr><td>可扩展性</td><td>无法通过增加节点提升吞吐量</td></tr><tr><td>网络敏感性</td><td>对网络分区和延迟变化敏感</td></tr><tr><td>地理分布</td><td>跨地域部署会增加协调开销</td></tr></tbody></table><h3 id="cap-定理的上下文" tabindex="-1"><a class="header-anchor" href="#cap-定理的上下文"><span>CAP 定理的上下文</span></a></h3><p>当网络分区发生时，系统必须在以下两者之间选择：</p><ul><li><strong>一致性（Consistency）</strong>：维护线性一致性但变得不可用</li><li><strong>可用性（Availability）</strong>：继续运行但失去线性一致性</li></ul><h3 id="性能影响" tabindex="-1"><a class="header-anchor" href="#性能影响"><span>性能影响</span></a></h3><p>线性一致性本质上需要协调，这使得它比最终一致性的替代方案更慢，特别是在跨地域场景下。</p><p><strong>优化策略</strong>：</p><ul><li>使用更弱的一致性模型（如因果一致性）</li><li>批量处理请求减少往返次数</li><li>使用租约（lease）减少协调频率</li></ul><h2 id="实际应用" tabindex="-1"><a class="header-anchor" href="#实际应用"><span>实际应用</span></a></h2><h3 id="协调服务" tabindex="-1"><a class="header-anchor" href="#协调服务"><span>协调服务</span></a></h3><table><thead><tr><th>系统</th><th>用途</th><th>共识算法</th></tr></thead><tbody><tr><td>ZooKeeper</td><td>分布式协调原语</td><td>Zab</td></tr><tr><td>etcd</td><td>键值存储，强一致性</td><td>Raft</td></tr><tr><td>Consul</td><td>服务发现，强一致性</td><td>Raft</td></tr></tbody></table><p><strong>提供的功能</strong>：</p><ul><li>领导者选举</li><li>分布式锁</li><li>配置管理</li><li>服务注册与发现</li></ul><h3 id="数据库系统" tabindex="-1"><a class="header-anchor" href="#数据库系统"><span>数据库系统</span></a></h3><p><strong>应用场景</strong>：</p><ul><li>单主数据库的自动故障切换</li><li>分布式数据库使用共识管理元数据</li><li>事务协调器实现原子提交</li></ul><p><strong>示例</strong>：</p><ul><li>Google Spanner：使用 Paxos 实现跨数据中心一致性</li><li>CockroachDB：使用 Raft 实现分布式 SQL</li><li>MongoDB：使用 Raft-like 协议进行副本集选举</li></ul><h2 id="核心理念" tabindex="-1"><a class="header-anchor" href="#核心理念"><span>核心理念</span></a></h2><p><strong>核心要点</strong>：</p><ol><li><strong>线性一致性</strong>是最强的一致性保证，但代价高昂</li><li><strong>共识算法</strong>是构建容错分布式系统的理论基础</li><li><strong>全序广播</strong>、<strong>原子提交</strong>、<strong>领导者选举</strong>本质上都是共识问题</li><li><strong>状态机复制</strong>通过共识实现强一致性</li><li><strong>CAP 定理</strong>说明分区时必须在一致性和可用性之间权衡</li><li>实际系统中，应根据需求选择合适的一致性级别</li></ol><p><strong>实践建议</strong>：</p><ul><li>不是所有场景都需要线性一致性，优先考虑更弱的一致性模型</li><li>使用成熟的协调服务（ZooKeeper、etcd）而非自己实现共识</li><li>理解共识的性能限制，避免在关键路径上过度使用</li><li>跨地域部署时，考虑使用多数据中心共识或最终一致性方案</li></ul>',47))])}const c=n(d,[["render",h]]),u=JSON.parse('{"path":"/ddia/nydpoapn/","title":"第10章 一致性与共识","lang":"zh-CN","frontmatter":{"title":"第10章 一致性与共识","createTime":"2025/12/26 09:54:02","permalink":"/ddia/nydpoapn/"},"headers":[],"readingTime":{"minutes":9.86,"words":2958},"git":{"updatedTime":1766740079000,"contributors":[{"name":"aidenreed937","username":"aidenreed937","email":"aidenreed937@gmail.com","commits":4,"avatar":"https://avatars.githubusercontent.com/aidenreed937?v=4","url":"https://github.com/aidenreed937"},{"name":"Claude Opus 4.5","username":"Claude Opus 4.5","email":"noreply@anthropic.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Claude Opus 4.5?v=4","url":"https://github.com/Claude Opus 4.5"},{"name":"Claude Sonnet 4.5","username":"Claude Sonnet 4.5","email":"noreply@anthropic.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Claude Sonnet 4.5?v=4","url":"https://github.com/Claude Sonnet 4.5"}]},"filePathRelative":"notes/ddia/part2-distributed/chapter-10.md","bulletin":false}');export{c as comp,u as data};
