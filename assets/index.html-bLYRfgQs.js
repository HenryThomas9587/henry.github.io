import{_ as i,c as l,b as t,a as e,d as n,e as d,r,o as p}from"./app-BNwF3TyR.js";const o={};function h(c,a){const s=r("Mermaid");return p(),l("div",null,[a[0]||(a[0]=t("blockquote",null,[t("p",null,[d("本章基于 "),t("a",{href:"https://ddia.vonng.com/ch9/",target:"_blank",rel:"noopener noreferrer"},"DDIA 中文翻译"),d(" 整理")])],-1)),a[1]||(a[1]=t("h2",{id:"章节概览",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#章节概览"},[t("span",null,"章节概览")])],-1)),e(s,{id:"mermaid-8",code:"eJydk0tPGlEUx/f9FCRua3QYUDCNCcwwTZO+0jTdTFy0qa2mJjVq+tjxEIUCIgYCwthBeYhpEB9I6IzKh+nce2dW/Qq9cGdwpmnsIKsL5/zOOf9z/rxfeb284Hj84p4Df3w8iG2AbgRcptG5jGQRFdc1SUaR+pxjfHzW4eeVbgqkW9peGUfQVQbJwhwhB3HGEof5jrYjmuMsr/ZKqJGAxTAIWcgAj8Sa2tpQultIEFGpaw5yPDiOg2gDBg9xHLZl/Ji7N0jwk7koHnZiMNTCvdXIldI9ANXTX8EQkDtqT8QPbTMFqilSU0ecPMyX4XkOJCUsWv0WRuGfoH0EpQjYSRJp/WUkJQtF82onioXBQgtkW0o32NeZi2pFAVaC8CIB4wl4fGFBXDwZQ/tRAFIdTwjShQdvViZm4daOVhBxJaUrg1JZV8SQTWJF+RrY2iBLdHxadYBUTj2JmJeqp/aV9H+El2F0KOPpHU9fPneA7SRs1rTdbRDrWNLpQXq+DWPneAIgpbEEkDrVdo8saS5eC8rqdUavXWjBUpucoS+51FPkij4xS25L8Q8ZvOpXT8h18fPRxDPUjIPrKCms5zl5dCgiqT6hZUPkXkBoEAYKIh5M7W3ih4Whea2YRXVZkasontQKZ7B5oK5n1EpYnyFAXETxoFqEuRPYvlbkM7USIlX0KF5UQgCpMpCa5GaWKM0Tz8PGPvieIBfKd/B+sBIjfZDPEVPiXoYrf18W4dk+FOJgL61ICZDOoKwuQE/GrQe2xZmgdoVzoBBEcszIHKSurn1dmseWf7e4tDQz5p1kfJz3/urayscP8zNjlHvKzUzqX8c/L75dW5ihl7+YQL8Oclxg0uMcghzn4Sb/Ap0WkNFBn5ud8k0PQWdgmqWNOv8EWR1kAl6a9QzBKR/l9/puAwPDUX1+LzUEWY+Lpty3gZz95fRB83Yo++uhrHt13pmk70y6RiPN1zSE2jintSljCB2dNISOThpCbZJm9xlCbdjP2pQ1hI5OGkJtkmbP3xjwv6a3Ng3cGHBU8saAtkjzP80Y18ZfzdqUM8a1Sf4BRPFRSA=="}),a[2]||(a[2]=n('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>本章深入探讨分布式系统中的核心挑战，揭示与单机系统的根本差异。分布式系统的关键特征是<strong>部分失效</strong>的可能性——系统的某些部分可能以不可预测的方式出现故障，而其他部分仍正常工作。</p><blockquote><p>&quot;在分布式系统中，我们尝试将对部分失败的容忍构建到软件中，这样即使某些组成部分出现故障，整个系统也可以继续运行。&quot;</p></blockquote><h2 id="不可靠的网络" tabindex="-1"><a class="header-anchor" href="#不可靠的网络"><span>不可靠的网络</span></a></h2><h3 id="网络通信的不确定性" tabindex="-1"><a class="header-anchor" href="#网络通信的不确定性"><span>网络通信的不确定性</span></a></h3><p>在异步分组网络中，发送请求但未收到响应时，可能的原因：</p>',6)),e(s,{id:"mermaid-29",code:"eJxLL0osyFDwCeJSAALH6Bfrtz/b2PS0f+LLhsZYBV1dOwWn6mdzVj2bsu1px4ank3uf7ppSC1bqBJZ0hmp4smPR0yUbY5FkXGBGzVnxcsb8px3Tn+xY+3xt59N9rciqXKNf7J/zfEX3i66m5007n27f9HTLyme7mpGVuKEoeTar6dn0bc+mL4C4BVmhezREDNMtHlAZbG4BKysuqcxJVXBUSMvMybFStjRwdnSz1CkuKcrPTrVSNjQ1M3U2gHJ1yzNTSjKsjAoqkDQ6QTW6ubkaWBjBNbq5WbgZ4NXoDNfo6GRpCNfoYmFibGiKT6MLuRpdydXoRq5Gd3I1epCmEQDRCAu9"}),a[3]||(a[3]=n('<blockquote><p>&quot;发送方甚至无法判断数据包是否已交付：唯一的选择是让接收方发送响应消息，而响应消息本身也可能丢失或延迟。&quot;</p></blockquote><h3 id="网络故障的现实" tabindex="-1"><a class="header-anchor" href="#网络故障的现实"><span>网络故障的现实</span></a></h3><table><thead><tr><th>场景</th><th>频率/影响</th></tr></thead><tbody><tr><td>中型数据中心网络故障</td><td>每月约 12 次</td></tr><tr><td>广域光纤链路中断</td><td>可能由动物或人为因素造成</td></tr><tr><td>数据中心内网络延迟</td><td>可能超过一分钟</td></tr><tr><td>网络分区</td><td>可能持续数分钟到数小时</td></tr></tbody></table><h3 id="tcp-的局限性" tabindex="-1"><a class="header-anchor" href="#tcp-的局限性"><span>TCP 的局限性</span></a></h3><p>虽然 TCP 提供&quot;可靠&quot;交付，但它无法解决所有网络问题：</p><ul><li>连接超时后，无法知道远程节点实际处理了多少数据</li><li>网络拥塞时，重传会加剧问题</li><li>无法区分节点崩溃和网络分区</li></ul><h3 id="网络延迟的来源" tabindex="-1"><a class="header-anchor" href="#网络延迟的来源"><span>网络延迟的来源</span></a></h3>',7)),e(s,{id:"mermaid-110",code:"eJxLL0osyFDwCeJSAALH6GcNu5/u3vZi//xYBV1dOwWn6Cd7FjybtBYqBlEElnGOftY36eWM+ZgyLtFPl7Q8n9AGkwFLOYOlXKOf7534fPecJ7uWPOtd9GzOLpABHdMhuiFK3KKfTe59snfO8827n++e/6xv6bMp2/Sf9k982dD4fM/kp22bnvbsQlbvHv1i5qxn3fOf9kx73rf+6aLm57Nans1qeto4B1mVR3SIc4DCs62NL9v7n/Utf9qxzSapSN/uWffSpwvnPV81/Wn/YqhDi0sqc1KBPknLzMmxUrY0cHZ0s9QpLinKz061UjY0NTN1NoBydcszU0oyrIwKKpA0OkE1Opq6mDmawzUauZq7GBvh0+gM1ejm5mpgAVMJ4lq4GeC10YVcG12hGp1dLY1dLOAazRwNnSwd8Wl0I1ejO7kaPUjTCAD6gw6K"}),a[4]||(a[4]=n('<blockquote><p>&quot;在公共云和多租户数据中心中，资源在许多客户之间共享&quot;，导致延迟高度可变。</p></blockquote><h3 id="超时设置" tabindex="-1"><a class="header-anchor" href="#超时设置"><span>超时设置</span></a></h3><p><strong>过短的超时</strong>：</p><ul><li>可能误判正常节点为故障</li><li>触发不必要的故障切换</li><li>增加系统负载</li></ul><p><strong>过长的超时</strong>：</p><ul><li>故障检测延迟</li><li>用户体验差</li><li>资源浪费</li></ul><p><strong>实践建议</strong>：</p><ul><li>使用自适应超时（基于历史延迟）</li><li>区分连接超时和读取超时</li><li>考虑使用心跳机制</li></ul><h2 id="不可靠的时钟" tabindex="-1"><a class="header-anchor" href="#不可靠的时钟"><span>不可靠的时钟</span></a></h2><h3 id="时钟类型" tabindex="-1"><a class="header-anchor" href="#时钟类型"><span>时钟类型</span></a></h3><table><thead><tr><th>类型</th><th>用途</th><th>特点</th></tr></thead><tbody><tr><td>日历时钟（Time-of-day）</td><td>获取当前日期时间</td><td>可能向后跳跃，受 NTP 调整影响</td></tr><tr><td>单调时钟（Monotonic）</td><td>测量时间间隔</td><td>保证向前移动，不受 NTP 影响</td></tr></tbody></table><h3 id="时钟同步的挑战" tabindex="-1"><a class="header-anchor" href="#时钟同步的挑战"><span>时钟同步的挑战</span></a></h3>',12)),e(s,{id:"mermaid-227",code:"eJxLL0osyFDwCeJSAALH6GfTt72cNP/Znqbny3c/m7v02a4JsQq6unYKTtHP529+0b3x2cxtT/ZOfrlo4vO+9qeN/U+3r7NJKtK3e9q//sW+fQpGBgYFBbmxELPA+pyjn+1Y+XTXsqf9M572THu6d+PTyb3I8i7RfiEBCk8n9Dxbu/Tp7m0v9s9HlnWNfjl9w/Plk54uaXk+oQ1Zxi36xcxZz7rnAw193rf+6aLm57NawC6BeAAuGcsF1lRcUpmTCtSalpmTY6VsaeDs6GapU1xSlJ+daqVsaGpm6mwA5eqWZ6aUZFgZFVQgaXSCanRzc3SyNIRrdLEwMTY0xafRGa7R1cDCCK7Rzc3CzQCvjS5QjY6mLmaO5nCNRq7mLsYwc7BqdIVqdHa1NHaxgGs0czR0snTEp9GNND8CAJdD19I="}),a[5]||(a[5]=n(`<p><strong>NTP 同步的局限</strong>：</p><ul><li>网络延迟导致同步精度有限</li><li>通常只能达到几十毫秒精度</li><li>网络故障时可能长时间不同步</li></ul><h3 id="时钟依赖的危险" tabindex="-1"><a class="header-anchor" href="#时钟依赖的危险"><span>时钟依赖的危险</span></a></h3><p><strong>问题场景</strong>：使用时间戳排序事件</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>节点A: 写入 x=1，时间戳 100ms</span></span>
<span class="line"><span>节点B: 写入 x=2，时间戳 99ms（时钟偏差）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>按时间戳排序：x=1 覆盖 x=2</span></span>
<span class="line"><span>实际因果顺序：x=2 应该覆盖 x=1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解决方案</strong>：使用逻辑时钟（Lamport 时间戳、向量时钟）</p><h3 id="google-spanner-的-truetime" tabindex="-1"><a class="header-anchor" href="#google-spanner-的-truetime"><span>Google Spanner 的 TrueTime</span></a></h3><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>TrueTime API 返回：[earliest, latest]</span></span>
<span class="line"><span>- earliest: 当前时间不早于此</span></span>
<span class="line"><span>- latest: 当前时间不晚于此</span></span>
<span class="line"><span></span></span>
<span class="line"><span>事务提交时等待置信区间，确保时间戳反映因果关系</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进程暂停" tabindex="-1"><a class="header-anchor" href="#进程暂停"><span>进程暂停</span></a></h2><h3 id="暂停的原因" tabindex="-1"><a class="header-anchor" href="#暂停的原因"><span>暂停的原因</span></a></h3><table><thead><tr><th>原因</th><th>持续时间</th><th>可预测性</th></tr></thead><tbody><tr><td>垃圾回收（GC）</td><td>毫秒到秒</td><td>部分可预测</td></tr><tr><td>虚拟机暂停/恢复</td><td>秒到分钟</td><td>不可预测</td></tr><tr><td>操作系统上下文切换</td><td>微秒到毫秒</td><td>不可预测</td></tr><tr><td>磁盘 I/O 等待</td><td>毫秒到秒</td><td>部分可预测</td></tr><tr><td>内存交换（Swap）</td><td>毫秒到秒</td><td>不可预测</td></tr><tr><td>信号处理</td><td>微秒</td><td>可预测</td></tr></tbody></table><h3 id="租约和分布式锁的问题" tabindex="-1"><a class="header-anchor" href="#租约和分布式锁的问题"><span>租约和分布式锁的问题</span></a></h3><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>时间线：</span></span>
<span class="line"><span>0s: 节点A获取租约（有效期10s）</span></span>
<span class="line"><span>5s: 节点A开始GC暂停</span></span>
<span class="line"><span>15s: 租约过期，节点B获取租约</span></span>
<span class="line"><span>20s: 节点A从GC恢复，认为自己仍持有租约</span></span>
<span class="line"><span>    → 脑裂！两个节点都认为自己持有锁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="隔离令牌-fencing-token" tabindex="-1"><a class="header-anchor" href="#隔离令牌-fencing-token"><span>隔离令牌（Fencing Token）</span></a></h3><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>解决方案：</span></span>
<span class="line"><span>1. 锁服务每次授予锁时返回递增的令牌</span></span>
<span class="line"><span>2. 客户端在操作时携带令牌</span></span>
<span class="line"><span>3. 存储服务拒绝旧令牌的操作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>节点A: 获取锁，令牌=33</span></span>
<span class="line"><span>节点A: 暂停...</span></span>
<span class="line"><span>节点B: 获取锁，令牌=34</span></span>
<span class="line"><span>节点B: 写入数据，令牌=34 ✓</span></span>
<span class="line"><span>节点A: 恢复，写入数据，令牌=33 ✗（被拒绝）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="知识、真相与谎言" tabindex="-1"><a class="header-anchor" href="#知识、真相与谎言"><span>知识、真相与谎言</span></a></h2><h3 id="多数派原则" tabindex="-1"><a class="header-anchor" href="#多数派原则"><span>多数派原则</span></a></h3><p>由于单个节点不可靠，分布式算法依赖于<strong>仲裁（Quorum）</strong>：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>N 个节点的系统：</span></span>
<span class="line"><span>- 需要 &gt; N/2 个节点同意才能做出决定</span></span>
<span class="line"><span>- 允许 &lt; N/2 个节点故障</span></span>
<span class="line"><span>- 防止脑裂</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="拜占庭故障" tabindex="-1"><a class="header-anchor" href="#拜占庭故障"><span>拜占庭故障</span></a></h3><p>当节点可能&quot;撒谎&quot;（发送错误或恶意信息）时：</p><table><thead><tr><th>故障类型</th><th>描述</th><th>容错难度</th></tr></thead><tbody><tr><td>崩溃故障</td><td>节点停止响应</td><td>较易</td></tr><tr><td>遗漏故障</td><td>节点丢失部分消息</td><td>中等</td></tr><tr><td>拜占庭故障</td><td>节点发送任意错误信息</td><td>非常困难</td></tr></tbody></table><p><strong>拜占庭容错</strong>：需要 3f+1 个节点才能容忍 f 个拜占庭故障节点。</p><p><strong>应用场景</strong>：</p><ul><li>航空航天系统</li><li>区块链/加密货币</li><li>多方不信任的系统</li></ul><h3 id="系统模型" tabindex="-1"><a class="header-anchor" href="#系统模型"><span>系统模型</span></a></h3><p>为了设计可靠算法，需要定义系统模型：</p><p><strong>时序假设</strong>：</p><table><thead><tr><th>模型</th><th>假设</th><th>适用场景</th></tr></thead><tbody><tr><td>同步模型</td><td>有界延迟和暂停</td><td>理论分析</td></tr><tr><td>部分同步模型</td><td>大部分时间同步</td><td>实际系统</td></tr><tr><td>异步模型</td><td>无时序假设</td><td>最保守</td></tr></tbody></table><p><strong>节点故障模型</strong>：</p><table><thead><tr><th>模型</th><th>假设</th></tr></thead><tbody><tr><td>崩溃停止</td><td>节点崩溃后永不恢复</td></tr><tr><td>崩溃恢复</td><td>节点可能崩溃并恢复</td></tr><tr><td>拜占庭</td><td>节点可能任意行为</td></tr></tbody></table><h3 id="安全性与活性" tabindex="-1"><a class="header-anchor" href="#安全性与活性"><span>安全性与活性</span></a></h3><p>算法属性分为两类：</p><table><thead><tr><th>属性类型</th><th>定义</th><th>示例</th></tr></thead><tbody><tr><td>安全性（Safety）</td><td>&quot;没有坏事发生&quot;</td><td>不会选出两个领导者</td></tr><tr><td>活性（Liveness）</td><td>&quot;好事最终会发生&quot;</td><td>最终会选出一个领导者</td></tr></tbody></table><p><strong>关键区别</strong>：</p><ul><li>安全性违反后无法撤销</li><li>活性通常包含&quot;最终&quot;的时间限定</li></ul><h2 id="测试和验证方法" tabindex="-1"><a class="header-anchor" href="#测试和验证方法"><span>测试和验证方法</span></a></h2><h3 id="形式化方法" tabindex="-1"><a class="header-anchor" href="#形式化方法"><span>形式化方法</span></a></h3><table><thead><tr><th>方法</th><th>描述</th><th>工具</th></tr></thead><tbody><tr><td>模型检查</td><td>验证算法在所有可能状态下的行为</td><td>TLA+, Alloy</td></tr><tr><td>定理证明</td><td>数学证明算法正确性</td><td>Coq, Isabelle</td></tr></tbody></table><h3 id="故障注入" tabindex="-1"><a class="header-anchor" href="#故障注入"><span>故障注入</span></a></h3>`,40)),e(s,{id:"mermaid-656",code:"eJxLL0osyFDwCeJSAALH6Gfbtz/b1PN0+9LnK7pjFXR17RScol/O6n82Z9fz3R3P1i56sX82SAaiGizvHP1s84qnrUuf7534fPecp7u3vdg/H1neJfrZioXPuudD5TvanvbsQpZ3jX66cPWz3QufL258PnvG85W7Xk7fgizvBtX/bPq2l5PmP23sf7p9XSwXWEFxSWVOKlBZWmZOjpWypYGzo5ulTnFJUX52qpWyoamZqbMBlKtbnplSkmFlVFCBpNEJqtHNzdHJ0hCu0cXCxNjQFJ9GZ7hGVwMLI7hGNzcLNwO8NrpANTqaupg5msM1GrmauxjDzMGq0RWq0dnV0tjFAq7RzNHQydIRn0Y30vwIAEyEw/M="}),a[6]||(a[6]=n('<h3 id="确定性模拟测试" tabindex="-1"><a class="header-anchor" href="#确定性模拟测试"><span>确定性模拟测试</span></a></h3><p>控制所有非确定性源（时间、网络、随机数），使测试可重现。</p><h2 id="核心要点" tabindex="-1"><a class="header-anchor" href="#核心要点"><span>核心要点</span></a></h2><ul><li>分布式系统的本质挑战是<strong>部分失效的非确定性</strong></li><li>网络、时钟、进程都不可靠，必须假设它们会出问题</li><li>超时和重试是处理网络故障的基本手段</li><li>避免依赖精确的时间同步，使用逻辑时钟</li><li>使用仲裁和隔离令牌防止脑裂</li><li>理解系统模型是设计正确算法的前提</li></ul>',4))])}const b=i(o,[["render",h]]),m=JSON.parse('{"path":"/ddia/cpolrctq/","title":"第9章 分布式系统的麻烦","lang":"zh-CN","frontmatter":{"title":"第9章 分布式系统的麻烦","createTime":"2025/12/26 16:12:54","permalink":"/ddia/cpolrctq/"},"headers":[],"readingTime":{"minutes":8.68,"words":2603},"git":{"updatedTime":1766740079000,"contributors":[{"name":"aidenreed937","username":"aidenreed937","email":"aidenreed937@gmail.com","commits":4,"avatar":"https://avatars.githubusercontent.com/aidenreed937?v=4","url":"https://github.com/aidenreed937"},{"name":"Claude Opus 4.5","username":"Claude Opus 4.5","email":"noreply@anthropic.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Claude Opus 4.5?v=4","url":"https://github.com/Claude Opus 4.5"},{"name":"Claude Sonnet 4.5","username":"Claude Sonnet 4.5","email":"noreply@anthropic.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Claude Sonnet 4.5?v=4","url":"https://github.com/Claude Sonnet 4.5"}]},"filePathRelative":"notes/ddia/part2-distributed/chapter-09.md","bulletin":false}');export{b as comp,m as data};
