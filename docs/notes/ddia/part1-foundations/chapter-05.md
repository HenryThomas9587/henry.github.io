---
title: 第5章 编码与演化
---

# 第5章 编码与演化

> 本章基于 [DDIA 中文翻译](https://ddia.vonng.com/ch5/) 整理

## 核心概念

### 编码与解码

**编码（Encoding/Serialization）**：将内存中的数据结构转换为字节序列，用于存储或网络传输。

**解码（Decoding/Deserialization）**：将字节序列还原为内存中的数据结构。

### 兼容性要求

系统演化过程中，新旧代码需要共存，因此需要满足：

- **向后兼容（Backward Compatibility）**：新代码能读取旧代码写入的数据
- **向前兼容（Forward Compatibility）**：旧代码能读取新代码写入的数据

> 向前兼容更具挑战性，因为旧代码需要忽略新增的未知字段。

## 数据编码格式

### 语言特定格式

如 Java 的 Serializable、Python 的 pickle 等。

**主要问题**：
- 语言绑定，无法跨语言使用
- 安全漏洞（可执行任意代码）
- 版本控制支持差
- 性能低下

**结论**：不推荐用于生产环境。

### 文本格式（JSON、XML、CSV）

| 特性 | JSON | XML | CSV |
|------|------|-----|-----|
| 可读性 | 高 | 中 | 高 |
| 语言支持 | 广泛 | 广泛 | 广泛 |
| 数据类型 | 有限 | 有限 | 无 |
| 模式支持 | JSON Schema | XML Schema | 无标准 |
| 二进制支持 | 需 Base64 | 需 Base64 | 不支持 |

**共同问题**：
- 数字编码模糊（整数 vs 浮点数，精度限制）
- 无原生二进制字符串支持
- CSV 缺乏标准化的转义规则

**适用场景**：人类可读性重要、数据量不大、跨语言互操作。

### 二进制模式驱动格式

#### Protocol Buffers

**核心特性**：
- 使用字段标签（数字）代替字段名
- 变长整数编码，紧凑高效
- 需要手动分配唯一标签号

**模式演化规则**：
- 可以���加新字段（使用新标签号）
- 可以删除字段（但不能重用标签号）
- 不能更改字段的数据类型

**示例模式**：
```protobuf
message Person {
  required string user_name = 1;
  optional int64 favorite_number = 2;
  repeated string interests = 3;
}
```

#### Thrift

与 Protocol Buffers 类似，提供两种二进制编码：
- **BinaryProtocol**：字段类型和长度信息
- **CompactProtocol**：更紧凑的变长编码

#### Avro

**独特设计**：
- 模式中不包含字段标签
- 需要同时使用写入模式（writer schema）和读取模式（reader schema）
- 通过字段名匹配进行模式解析

**模式演化规则**：
- 只能添加/删除有默认值的字段
- 可以更改字段名（通过别名）
- 不能更改字段的数据类型

**优势**：
- 动态生成模式（适合数据库导出）
- 编码更紧凑（无标签号开销）
- 模式演化更灵活

**示例模式**：
```json
{
  "type": "record",
  "name": "Person",
  "fields": [
    {"name": "userName", "type": "string"},
    {"name": "favoriteNumber", "type": ["null", "long"], "default": null},
    {"name": "interests", "type": {"type": "array", "items": "string"}}
  ]
}
```

### 编码格式对比

| 特性 | JSON/XML | Protocol Buffers | Thrift | Avro |
|------|----------|------------------|--------|------|
| 可读性 | 高 | 低 | 低 | 低 |
| 编码大小 | 大 | 小 | 小 | 最小 |
| 模式定义 | 可选 | 必需 | 必需 | 必需 |
| 字段标识 | 名称 | 标签号 | 标签号 | 名称 |
| 代码生成 | 不需要 | 需要 | 需要 | 可选 |
| 动态模式 | 支持 | 不支持 | 不支持 | 支持 |

## 模式的优势

> "模式演化提供了与无模式/读时模式 JSON 数据库相同的灵活性，同时提供了更好的数据保证和工具支持。"

**核心优势**：
1. **紧凑编码**：省略字段名，减少存储空间
2. **活文档**：模式是解码的必要条件，强制保持更新
3. **兼容性检查**：部署前验证模式变更的兼容性
4. **代码生成**：静态类型语言的类型安全保证

## 数据流模式

### 数据库中的数据流

**核心挑战**：数据的生命周期远长于代码。

> "五年前的数据仍然存在，保持着原始编码格式。"

**演化策略**：
- **简单变更**：添加可空列，无需重写数据
- **复杂重构**：需要数据迁移，成本高昂
- **归档存储**：统一编码格式的好时机

**最佳实践**：
- 使用模式演化而非大规模迁移
- 在应用层处理多版本数据
- 归档时转换为标准格式

### 服务中的数据流（REST 与 RPC）

#### Web 服务

**REST 原则**：
- 简单的数据格式（通常是 JSON）
- 使用 HTTP 特性（缓存、认证、内容协商）
- 基于 URL 的资源定位

**服务定义**：
- OpenAPI（Swagger）：用于 JSON API
- gRPC：基于 Protocol Buffers

**框架集成**：
- 代码优先（Code-first）：如 FastAPI，从代码生成 API 文档
- 模式优先（Schema-first）：如 gRPC，从模式生成代码

#### RPC 的问题

> "RPC 模型试图让远程网络服务调用看起来像调用同一进程内的函数或方法。"

**根本问题**：
- 网络请求不可预测（超时、失败）
- 延迟差异巨大（本地调用纳秒级，网络调用毫秒级）
- 参数编码开销
- 跨语言类型映射困难

**现代 RPC 框架**：
- gRPC（Protocol Buffers）
- Finagle（Thrift）
- Rest.li（JSON over HTTP）

#### 服务基础设施

**负载均衡**：
- 硬件负载均衡器
- 软件负载均衡器（如 HAProxy、Nginx）
- DNS 负载均衡
- 服务发现（如 Consul、etcd）

**服务网格（Service Mesh）**：
- 进程本地负载均衡器
- 加密、可观测性、流量控制
- 示例：Istio、Linkerd

**API 版本控制**：
- 基于 URL：`/api/v1/users`
- 基于 Header：`Accept: application/vnd.api+json; version=1`
- 客户端特定配置

### 工作流系统

#### 持久化执行（Durable Execution）

> "持久化执行框架是一种为工作流提供精确一次语义的方法。"

**核心特性**：
- 持久化记录所有 RPC 调用和状态变更
- 失败时自动重试，重放之前的结果
- 提供精确一次执行保证

**挑战**：
- 要求代码确定性
- 外部 API 需要幂等性
- 长时间运行的工作流管理

**典型框架**：
- Temporal
- Cadence
- AWS Step Functions

### 事件驱动架构

#### 消息代���

**相比直接 RPC 的优势**：
- 缓冲机制提高可靠性
- 自动消息重传
- 无需服务发现
- 一对多消息传递
- 逻辑解耦

**分发模式**：
- **队列（Queue）**：每条消息只被一个消费者接收
- **主题（Topic）**：所有订阅者都接收每条消息

**消息代理示例**：
- RabbitMQ
- Apache Kafka
- Amazon SQS/SNS
- Google Pub/Sub

#### Actor 框架

> "位置透明性在 Actor 模型中比 RPC 中效果更好，因为 Actor 模型已经假设消息可能丢失。"

**核心概念**：
- 每个 Actor 是独立的并发实体
- 通过异步消息通信
- 内置消息丢失假设

**分布式 Actor 系统**：
- Akka（JVM）
- Orleans（.NET）
- Erlang OTP

**优势**：
- 天然适合分布式环境
- 容错性内建
- 位置透明性

## 演化策略

### 滚动升级

**核心原则**：
- 新旧版本代码共存
- 逐步替换节点
- 保持服务可用性

**要求**：
- 向后兼容：新代码读旧数据
- 向前兼容：旧代码读新数据

### 模式演化最佳实践

1. **添加字段**：
   - 使用可选字段或提供默认值
   - 新字段使用新的标签号/名称

2. **删除字段**：
   - 确保所有读取者已升级
   - 不要重用标签号/名称

3. **更改字段类型**：
   - 通常不安全，避免使用
   - 考虑添加新字段并逐步迁移

4. **重命名字段**：
   - Protocol Buffers/Thrift：只影响代码，不影响编码
   - Avro：使用别名支持

### 数据流中的兼容性

| 数据流类型 | 向后兼容 | 向前兼容 | 关键点 |
|-----------|---------|---------|--------|
| 数据库 | 必需 | 必需 | 数据长期存在 |
| REST API | 必需 | 推荐 | 客户端版本多样 |
| RPC | 必需 | 必需 | 滚动升级 |
| 消息传递 | 必需 | 必需 | 异步处理 |

## 本章总结

```
第5章 编码与演化
 ├── 编码格式
 │    ├── 语言特定格式（不推荐）
 │    ├── 文本格式（JSON/XML/CSV）
 │    └── 二进制模式驱动格式
 │         ├── Protocol Buffers（标签号）
 │         ├── Thrift（标签号）
 │         └── Avro（字段名 + 模式解析）
 ├── 模式演化
 │    ├── 向后兼容（新读旧）
 │    ├── 向前兼容（旧读新）
 │    └── 演化规则（添加/删除/修改字段）
 ├── 数据流模式
 │    ├── 数据库（数据长期存在）
 │    ├── 服务（REST/RPC）
 │    │    ├── 负载均衡
 │    │    ├── 服务网格
 │    │    └── API 版本控制
 │    ├── 工作流系统（持久化执行）
 │    └── 事件驱动
 │         ├── 消息代理（队列/主题）
 │         └── Actor 框架
 └── 演化策略
      ├── 滚动升级
      ├── 模式兼容性检查
      └── 渐进式迁移
```

**核心理念**：

> "通过一点小心，向后/向前兼容性和滚动升级是完全可以实现的。愿你的应用演化迅速，部署频繁。"

**关键要点**：
- 选择合适的编码格式是系统演化的基础
- 模式提供了灵活性和安全性的平衡
- 理解数据流模式有助于设计兼容的系统
- 滚动升级需要新旧代码共存的能力
- 简单的模式演化胜过复杂的数据迁移
